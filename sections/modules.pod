Z<modules>

Packages correspond to files on disk in that when you load a module with C<use>
or C<require>'s bareword form, Perl splits the package name on double-colons
(C<::>) and turns the components of the package name into a file path.  Thus:

=begin programlisting

    use StrangeMonkey;

=end programlisting

... causes Perl to search for a file named F<StrangeMonkey.pm> in every
directory in C<@INC>, in order, until it finds one or exhausts the list.  As
well:

=begin programlisting

    use StrangeMonkey::Persistence;

=end programlisting

... causes Perl to search for a file named C<Persistence.pm> in every directory
named F<StrangeMonkey/> present in every directory in C<@INC>, and so on.
Finally:

=begin programlisting

    use StrangeMonkey::UI::Mobile;

=end programlisting

... causes Perl to search for a relative file path named
F<StrangeMonkey/UI/Mobile.pm> in every directory in C<@INC>.  In other words,
if you want to be able to load your module C<StrangeMonkey::Test::Stress>, you
must have a file named F<StrangeMonkey/Test/Stress.pm> reachable from some
directory in C<@INC>.

=begin sidebar

There is I<no> technical requirement that the file at that location contain any
C<package> declaration, let alone a C<package> declaration matching the name of
the file.  Maintenance concerns highly recommend that you do so, however.

=end sidebar

=for author

Remove some ugly from the next paragraph.

=end for

Beware that some filesystems ignore case.  You may save a file as
F<StrangeMonkey.pm> and load it successfully with C<use Strangemonkey;>, but
the typo will cause problems when calling C<import()> or checking the version
of the module and it may prevent your code from working on other platforms or
on filesystems which preserve the case of file and directory names.

=for author

differences between packages and modules
    - packaging
    - installability
    - automated testing
    - dependencies tracked

exporting
    - Exporter
    - import()
    - BEGIN
    - circular imports

package design
    - API design
    - parsimony of symbols/exports
    - re-entrancy/thread safety
    - global concerns

why reuse the CPAN infrastructure?
    - good tools
    - automation
    - reporting
    - dependency tracking
    - consistent installation paths

local CPAN repository?
    - too advanced?  Nice to discuss, if there's space

=end for
